
<p><b>What is OMSI?</b>.</p>

OMSI, short for Online Measurement of Student Insight, is a Python project made for conducting and grading examinations in a manner that is
both secure and conducive to high-quality measurement of student insight. It is suitable for small or large class quizz, test or exam:
be it essay, programming, math or multiple choice question.

How to use this project package?

Step 1a: Coding a script

To use this project package to code a script that is supposed to be triggered by a certain command from the client, use Server.py.
Server.py is the main method on the professor's machine. It will be running for the entire duration of the exam. Server.py accpets request
from clients, allowing students to dump files and start the grading system.

(Or) Step 1b: Coding a class/module

To use this project package to code a class/module that is suppsed to be run upon a client request, write code in yout class and link it
to Server.py via an import. Add
import MyClassName
to the top of Server.py, do not put your functions or any code into Server.py.

Calling your function from client's machine

Add the function to the function dictionary in Server.py (function dictionary is a list of all function objects that is mapped to be a
string representative for the function, usually the function name). Find the variable
gFunctionDictionary = { ... a bunch of functions ...}
and add your function to the table above as follow:
"nameOfMyFunctionUNIQUE": MyClassWhichIImported.nameOfMyFunction
Note that yout function should not accept any parameters, as the actual function will be called without passing in any parameters.
Please also note that it is important that the first string "NameOfMyFunctionUNIQUE" is indeed unique. It is ideal to keep the function
name as close to the actual name of the function as possible, but still different from the other functions in the table.

Step 2: Running Server.py
Run Server.py to set up a server to listen to the Clients. Do not run any client script before running Server.py. After checking that both
the import and the functions are added to the function table, call your function
Client.callFunctionOnServer("nameOfMyFunctionUNIQUE")

Step 3: Confirguing Client.py
Write code in your class and module, do not modify Client unless you clearly now what you are doing. Import ServerInteractor in the class/
module that requires the server interaction like the following:
import Client
As of right now, you have two functions available: Client.setUpServer(pPort, pHost) and Client.callFunctionOnServer(functionName). Call
Client.setUpServer(pPort, pHost) by passing in the port and IP address provided by the professor to pPort and pHost respectively. If you
are just doing a test run, simply call the function by Client.setUpServer(0, 0).

Step 4: Linking Server.py to Client.py
Make sure the function you are trying to execute exists on the server side and is ready to be called by the client. If everything is
properly set up, call
Client.callFunctionOnServer("myFunctionName")
The return value of the function is either True or False, depending on whether the execution of the function on the server is successful
or not.
If unfortunately the return value is False, please which whether the server is set up properly. If it is, the issue might be more
complicated, which you are free to contact Francios to fix the problem.

Step 5: Running Client.py
Execute the Client script, but do not execute Client, for it is not supposed to be executed by itself.

What does the program do when executing Server.py and Client.py?
After everything is properly connected, students will connect to their server on their machines with their email addresses. When
sussecssful, the server will calculate and display the number of current connections and total connections to the professor, so that it is
detectable how many students are taking the exam, and is detectable when students face connection problem. Server.py then creates folders
for each individual student, uses the folders to store students' answer and send the test questions to the students. Once the students
receive their test questions, the internal clock will start to count down the time remaining for the students to do the test. Once the
time is up, the program will automatically save the students' answer. During the time from students' first connection to the server till
the end of the test, their activities on their laptops are being monitored by an external program PyShark, the data is stored in the
file specially created for inidivual students along with their test answers.

What happen after the test end? How does to autograding work?
The autograding program is semi-autograded. It goes through the students' file answers.txt in their individual directory with the name of
their emailname (e.g. jsmith@ucdavis.edu -> jsmith) to parse students' answer and a master answer file with the name Answerx, where x is
the test ID. It then displays both sets of answers to the professor. If there are any formatting errors, the program will alert the
professor. The professor needs to manually fix the files and decides how many points to award and applies any
late penalties if deemed necessary. All results are then stored in an output file.

Summary of each file on this site (in alphabetical order)

AutoGrade.py
A program to grade the students' answer electronically and automatically (translated from Prof. N. Matloff's AutoGrade.R, included in this site).

Checksum.py
A program to convert content of students' answer to hexadecimal for grading.

Client.py
A program that gets host, port number, exam files, duration of examination from user, and monitor process on students' machine during the examination.

ClientGlobals.py
A program that provides global variables of host socket to be used by other programs.

ClientRoutines.py
A program that connects the localhost server to the port 20500, providing an interface for server related activities.

ExampleScriptClientSide.py
A sample script on how to use Client interface.

ExampleScriptServerSide.py
A sample script on how grading scripts can be run on Server.

NetworkMonitor.py
A program to store network traffic of students' machines while students are taking the examination.

ProcessMonitor.py
A program to store the start time of the examination and process attributes e.g. name, record number, process id.

Server.py
A program to display whether connection can be made between the Client and the server, if success, the address of the connection.

ServerGlobals.py
A program that provides the number of active and nonactive clients(students) during the examination.

ServerRoutines.py
A program that allows students to connect to the server to access the examination materials.


Documentation

Server Client Interaction:

Client:

For all Server interactions on the Client side, please follow the following protocol.

Coding:

If you are coding and you need an interaction from the server --
Write code in your class, your module, please do not modify Client unless you really know what you are doing.
Import ServerInteractor in the class/module that requires the server interaction like this:
import Client
Now you have 2 functions available: Client.setUpServer(pPort, pHost) and Client.callFunctionOnServer(functionName)

Before you can do any interaction with the server, you need to call Client.setUpServer(pPort, pHost). The parameters are the port and the IP address provided by the professor.
*Until we actually are in a position to test this in a real setting (test run) call the function like so:
Client.setUpServer(0, 0)*

Now the server is configured on the client side. If you want to interact with the server now you need to do this by telling the server what function to execute.
Make sure the function you are trying to execute actually exists on the server and it is set up to be called by the client. Look at the Server section to find out how to set up the Server properly.

If everything is properly set up call:
Client.callFunctionOnServer("myFunctionName")

The return value of this is either True or False depending on whether the execution of the function on the server was successful or not.

If the return value is False, either there is a problem when you set up the server, or the issue is more complicated, in which case I would suggest contacting Francois or using your crazy coding skills to fix the issue yourself.

Running code:
For now, make sure to run "Server.py". This file does not take any arguments, just execute it, it sets up a server on localhost which starts listening.
Once that is done, just execute your Client script. Do not execute Client, it is not supposed to be executed by itself.




Server:

For all the code that is supposed to be run on the Server side, please follow the following protocol.

Coding:

If you are coding a script that is supposed to be triggered by a certain command from the client, or if you are writing something that needs to always run on the Server you need to link it to Server.py .
Server.py is the main method on the professor's machine. It should be executed by the professor ONCE and then it is supposed to be running for the entire duration of the exam. Serve.py accepts request from clients, allows students dump files and start the grading system etc.

If you are coding a class/module that is supposed to be run upon a client request please do not put your functions or any code into Server.py. Write your code in your class and then link it to Serve.py via an import. Simply add
import MyClassName
to the top of Server.py

In order for a function to be callable from a client's machine you need to explicitly add it to the function dictionary in Server.py . The function dictionary is a list of all function objects that is mapped to a string representative for the function (usually the function name)
In Server.py you ll find a variable called
gFunctionDictionary = { ... a bunch of functions ...}

Add your function to that table as follows:
'nameOfMyFunctionUNIQUE': MyCLassWhichIImported.nameOfMyFunction,

it is important that the first string (in my example: "nameOfMyFunctionUNIQUE") is indeed unique. I would try to keep it as close to the actual name of the function as possible, but still different from the other functions in the table.

As of right now, any functions you add to the function table will be called without passing in any parameters. In my example, at some point the program would call:
MyCLassWhichIImported.nameOfMyFunction()

This should match your actual function, so please do not make them accept parameters.

Running:

Before running any client scripts, run Server.py . It sets up a server and listens to the Clients.

If you added both the import and the functions to the function table, the Server Side is all set. Now just go ahead and call your function from the Client like so:
Client.callFunctionOnServer("nameOfMyFunctionUNIQUE")

(make sure your client side is correctly set up, please refer to the Client section should you encounter any difficulties)
