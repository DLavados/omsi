#! /usr/bin/python
__author__ = 'Vishal Chakraborty'

import sys, subprocess
import os
import filecmp
import time


"""
REQUIREMENTS: 	Instructor's Info File (txt)
				txt File containig the names of input files
				txt File containng the names of output file
				Input Files from Instructor
				Output Files from Instructor

---Instructor's Info File format (.txt)---

 INPUT: Text file in the following format
<option for compiling 1 : Yes 0 : Otherwise> <if 1 then max compilation time required in seconds>
<student file type>
<compiler> 
<exectution command>
<output type> <if 1 : Standard Output; 2 : File Output if 2 then name of studentSoulution>
<name of file with Sample Input file names>
<name of file with Mater Output file names>
<max run time in seconds>

option: using compiler = 1 if 1, max compile time
student file type: the type of the program file
compiler: name of the compiler ex. gcc, g++, python3, python...
exectution command: command line to run the program (with optional input files specified in the command)
output type: std = 1; file = 2   studentSolution: ***
instructSolution: Instructor's Solution filename
max run time: timeout for running/compiling in second


--- txt File containig the names of input files ---
<input1>
<input2>
.
.
.

--- txt File containig the names of Master Output files ---
<output1>
<output2>
.
.
.


"""
#Set global variables

#ARGV[1] -> Name of the program to be graded
#ARGV[2] -> Name of the Info File provided by the Instructor
#ARGV[3] -> Log File pointer

#The following are provided in the Info File
C_OPTION = 0				#Compiling required ? 0 = No, 1 =Yes
MAKEFILE = 0				#Makefile Name 
COMPILER = 0				#Compiler
EXEC_NAME = "a.out"			#Executable name 
OUTPUT_TYPE = 1				#Type of O/P by the student's program 1 = Standard O/P, 2 = File O/P 
STUDENT_SOLUTION = None		#If OUTPUT_TYPE = 2, then name of the file 
INSTRUCTOR_KEY = None		#Master Answer File 
RUN_TIMEOUT = 0.5				#How long to wait while running program 
C_TIMEOUT = 1.0				#How long to wait while Compiling program 

#Input Type
    #Functionality TO BE ADDED

#Output Type
STD_OUTPUT = 0				#Set to 1 if Standard Output
F_OUTPUT = 0				#Set to 1 if File Output


#Function makeExecutable -- for Compiled Languages
#Requirements: COMPILER, EXEC_NAME, studFile
#Returns ERROR-CODE 0 = Success
#Creates an executable EXEC_NAME in the student directory
def makeExecutable():
	
	msg = ""  #records print msgs
	infile = None  #for proc
	outfile = None #for proc

	#generating executable...
	proc = subprocess.Popen([COMPILER, "-o", EXEC_NAME, studFile], stdin = infile, stdout = outfile, stderr = subprocess.PIPE, universal_newlines = True)
	
	#print "hello, it's ME"
	
	retCode = proc.poll()
	while retCode is None:  #process is NOT complete yet...kill
		time.sleep(float(C_TIMEOUT))  #wait for process to finish
		proc.kill()		#kill process if it is still running
		msg = "\nExecutable could NOT be genarated: Compile - Time Out.\n"
	
	if retCode is not None and retCode != 0:
		msg = "Executable could NOT be genarated:\n" + proc.communicate()[1] + "\n"
	else:
		msg = "\nExecutable generated.\n"
	
	logFp.write(msg)
	print msg
	return retCode


#Function renExecutable  -- for Compiled Languages
#Requirements: EXEC_NAME, inputFile, ind
#Returns ERROR CODE 0 = Success, -999 = TIMEOUT
#Runs executable generated by makeExecutable()
#Creaates studSol.txt in Stats dir
#TO DO
#Integrate File Output and Input Option
def runExecutable(inputFile, ind):

	msg = ""
	infile = None  #for proc
	fname = studFile + '_S_Sol_' + str(ind)+'.txt'  #name of (ind)th Student Solution
	outfile = (fname)  #for proc
	
	execCommand = './' + EXEC_NAME + '<' + inputFile + '>' + outfile
	proc = subprocess.Popen([execCommand], stdin = infile, stdout = None, stderr = subprocess.PIPE, universal_newlines = True, shell = True)
	 
	retCode = proc.poll()  #get process status
	
	while proc.poll() is None:  #process is NOT complete yet...kill
		time.sleep(RUN_TIMEOUT)  #wait for process to finish
		proc.kill()		#kill process if it is still running
		

	if retCode != 0:
		if retCode is None:
			msg = "\nFailed to genarate Output: Time Out."
		else:
			msg = "Failed to genarate Output: " + proc.communicate()[1].strip() + "\n"
		fpOFile = fopen(outfile, 'w')
		fpOFile.write(msg)	
		print msg
		fpOFile.close()
	else:
		##display the output file



#Function runProg -- for Interpreted Languages
#Requirements:COMPILER, inputFile, ind
#Creates a studSol.txt in Stats dir of the student
#TO DO 
#Integrate File Output and Input Option



#Function checkSolution
#Requirements 
#	instructSolution -- Master Anwer File
#	studSolution -- Student's answer -- will depend upon if File or Standard Output
#Creates diff.txt in the Stats dir
#TO DO
#Grading Rules have to be implemented 
def checkSolution( instructSolution, studSolution, ind):
	
	result = -1
	
	if result == -1:    #following routine is simillar to diff -w
		iFp = open(instructSolution, 'r')
		sFp = open(studSolution, 'r')
		iFile = iFp.readlines()
		sFile = sFp.readlines()

		key = []
		out = []
		
		for line in iFile:
			key += line.strip().split()

		for line in sFile:
			out += line.strip().split()
		
		key = "".join(key)
		out = "".join(out)

		#print key
		#print out

		if(out == key):
			result = 0
		else:
			result = 1
	
	if result == 0:
		msg = 'Test Passed'
	else:
		msg = 'Test Fail'
		
	logFp.write(msg)
	print msg

	

#Changes to Variables in CAPS to be made with extreme caution -- contains info from the Instructor's Info File
if __name__ == "__main__":


	global studFile #name of student's program
	studFile = sys.argv[1] 
	studFp = open(studFile)

	infoFile = sys.argv[2]  #instructor's info file
	infoFp = open(infoFile)

	global rootPath  #has the path of the info File, also, the parent directory
	rootPath = os.path.dirname(os.path.realpath(infoFile))

	global prevDir 
	prevDir = os.getcwd()   #prevDir set to Student dir
	
	#global statsFolder  #New folder created to store diff and sol files of the student ~Temporary 'Scratch' File
	#statsFolder = "Stats" 
	
	#if not os.path.exists(statsFolder): #check if Stats dir exits
		#os.makedirs(statsFolder)  #create #Stats dir
	
	#os.chdir(statsFolder)  #step into statsFolder
	
	#global currDir 
	#currDir = os.getcwd() #currDir set to Stats dir

	#A log file is created which records the outcome of the entire run
	global logFp = argv[3]		   #log File pointer
	#logFp = open(studFile + 'log.txt', 'w')
	

	#getting information from the Instructor's info file
	contents = infoFp.readlines()
	#print contents
	C_OPTION = float(contents[0].split()[0])	# <option for compiling> <if 1 then compile time out required>
	if C_OPTION == 1:
		C_TIMEOUT = contents[0].split()[1]  #read C_TIMEOUT - the maximum compile time
	MAKEFILE = contents[1].split()[0]		# <answer file type>
	COMPILER = contents[2].split()[0] 	 #<compiler> The compiler to be used
	EXEC_NAME = contents[3].strip() 	# <executable file name>
	OUTPUT_TYPE = int(contents[4].split()[0]) 	#<output type> < type = 1 for Standard Output; type = 2 for file output, file name required>
	if OUTPUT_TYPE == 1:
		STD_OUTPUT = 1  #Expect Standard Output - STD_OUTPUT set to 1
	else:
		F_OUTPUT = 1  #Expect File Output - F_OUTPUT set to 1
		STUDENT_SOLUTION = contents[4].split()[1] #file name genarated by student's prog
	
	MASTER_IFILE_NAME = rootPath + '/' + contents[5].strip()  #file that contains the name of all input files
	##getting the names all the input file names from INPUT_FILE_NAME
	fpIFile = open(MASTER_IFILE_NAME)
	MASTER_IFILE_LIST = fpIFile.readlines()  #List of all the input file names
	#print "THE INPUT FILE..............", INPUT_FILE
	
	MASTER_OFILE_NAME = rootPath + '/' + contents[6].strip() #file that contains the name of all the output files
	#getting the names of all the output files
	fpOFile = open(MASTER_OFILE_NAME)
	MASTER_OFILE_LIST = fpOFile.readlines() #List of all the output file names

	RUN_TIMEOUT = float(contents[7].strip()) 	# <max run time>
	# end reading the lines

	NUM_OF_CASES = len(MASTER_IFILE_LIST)  #total number of test cases = number of input files provided
	


	if C_OPTION == 1:  #for Compiled Languages
		executable = makeExecutable()  #attempting to genarate executable...
		if executable == 0:  #check if executable created
			#executable genarated successfull, now run it with all the input cases provided and record status in OUTPUT_STAT_LIST[]
			#0 - Output created; 1 - Output was created
			for i in range(0, NUM_OF_CASES):
				runExecutable(rootPath + '/' + MASTER_IFILE_LIST[i].strip(), i+1)
	elif C_OPTION != 1:  #for Interpreted Languages
		#To be integrated later

	

	#Attempting to diff outputs against Master Outputs
	for i in range(0, NUM_OF_CASES):
		
		if C_OPTION == 1 and executable != 0:  #check if executable is required and was genarated or not
			break #If not genarated then STOP
		
		iKey = (rootPath + '/' + MASTER_OFILE_LIST[i]).strip() #name of ith Master Output
		studSol = studFile + '_S_Sol_' + str(i+1) + '.txt' #name of ith Student Output
		logFp.write('\nOUTPUT #' + str(i+1) + ':')  #write to log file
		
		if STD_OUTPUT == 1:  #if std-o/p then check with Student output
			checkSolution(iKey, studSol, i+1)
		else:  #output type = 2, check with student genarated file
				#To be integrated later




